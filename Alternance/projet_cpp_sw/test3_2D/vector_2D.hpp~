#pragma once

#include<iostream>
#include<vector>
#include<initializer_list>


struct Point2D {
  double x,y;
  Point2D (double abs, double ord): x(abs), y(ord){}
};

template <typename T>
class Array2D{
private:
  std::size_t _Nx;
  std::size_t _Ny;
  std::size_t _Stride_i;
  std::vector<T> _data;

public:
  Array2D(std::size_t x, std::size_t y) :
    _Nx(x), _Ny(y), _Stride_i(y), _data(x*y) {}

  ~Array2D() {}

  inline T& operator()(std::size_t i, std::size_t j) { return _data[index(i,j)]; }
  inline const T& operator()(std::size_t i, std::size_t j) const { return _data[index(i,j)]; }
 
  std::size_t strideI() const { return _Stride_i; } 
  T* data() { return _data.data(); }
  const T* data() const { return _data.data(); }
  const std::size_t get_x_dimension() const { return _Nx ;}
  const std::size_t get_y_dimension() const { return _Ny ;}
  const std::size_t get_nb_points() const { return _Nx*_Ny ;}

  std::size_t index(std::size_t i, std::size_t j) const {
  #ifdef S3D_BOUNDS_CHECK
  if (i>=_Nx || j>=_Ny) throw std::out_of_range("Array2D: index out of range");
  #endif
  return i*_Stride_i + j;
  }
  
};
