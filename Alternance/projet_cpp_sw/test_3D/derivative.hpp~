#pragma once

#include <iostream>
#include <cmath>
#include <vector>
#include "vector_3D.hpp"

struct domaine_size{
  double Lx{}, Ly{} , Lz{};
};

template <typename T>
struct step_size{
  double hi, hj , hk;
  step_size(const Grid3D& g, const domain_size& L):
    hi(L.Lx/static_cast<double>(g.NI)) ,
    hj(L.Ly/static_cast<double>(g.NJ)) ,
    hk(L.Lz/static_cast<double>(g.NK)) {}
  
};

template <typename T>
class derivative_3D{
protected:
  step_size _h{};
  Grid3D _G{};
  Array3D<T> _dx , _dy ,_dz , _delta;
  bool _dx_computed = false;
  bool _dy_computed = false;
  bool _dz_computed = false;

public:
  derivative_3D(const step_size& h, const Grid3D& g):
    _h(h),
    _G(g),
    _dx(g.NI * g.NJ * g.NK),
    _dy(g.NI * g.NJ * g.NK),
    _dz(g.NI * g.NJ * g.NK),
    _delta(g.NI * g.NJ * g.NK);

  virtual ~derivative_3D() {}

  const Grid3D& get_nb_nodes() const{ return _G;}
  const step_size& get_step_size() const { return _h;}
  const Array3D<T>& get_derivative_x() { return _dx;}
  const Array3D<T>& get_derivative_y() { return _dy;}
  const Array3D<T>& get_derivative_z() { return _dz;}
  const Array3D<T>& get_laplacien() { return _delta;}

  virtual void second_der_x() = 0;
  virtual void second_der_y() = 0;
  virtual void second_der_z() = 0;
  virtual void laplacien() = 0;
};

template <typename T>
class DF_o2 : public derivative_3D<T>{
public:
  using derivative<T>::_h;
  using derivative<T>::_G;
  using derivative<T>::_dx;
  using derivative<T>::_dy;
  using derivative<T>::_dz;
  using derivative<T>::_delta;
  
  DF_o2(const step_size& h , const Gride3D& g) : derivative_3D<T>(h, g) {}

  template <typename Func>
  void second_der_x(Func f) override {
    for (std::size_t i=0; i< _G.NI ; ++i){
      for (std::size_t j=0; j<_G.NJ; ++j){
	for (std::size_t k=0; k<_G.NK; ++k){
	std::size_t ip1 = (i + 1) % _G.NI;
	std::size_t im1 = (i + _G.NI - 1) % _G.NI;
	_dx(i,j,k) = (f(ip1,j,k) - 2.0*f(i,j,k) + f(im1,j,k)) / std::pow(_h.hi,2.0);
	}
      }
    }
    _dx_computed = true;
  }
  template <typename Func>
  void second_der_y(Func f) override {
    for (std::size_t i=0; i< _G.NI ; ++i){
      for (std::size_t j=0; j<_G.NJ; ++j){
	for(std::size_t k=0; k<_G.NK; ++k){
	std::size_t jp1 = (j + 1) % _G.NJ;
	std::size_t jm1 = (j + _G.NJ - 1) % _G.NJ;
        _dy(i,j,k) = (f(i,jp1,k) - 2.0*f(i,j,k) + f(i,jm1,k)) / std::pow(_h.hj,2.0);
	}
      }
    }
    _dy_computed = true;
  }
  template <typename Func>
  void second_der_z(Func f) override {
    for (std::size_t i=0; i< _G.NI ; ++i){
      for (std::size_t j=0; j<_G.NJ; ++j){
        for(std::size_t k=0; k<_G.NK; ++k){
        std::size_t kp1 = (k + 1) % _G.NK;
        std::size_t km1 = (k + _G.NK - 1) % _G.NK;
        _dz(i,j,k) = (f(i,j,kp1) - 2.0*f(i,j,k) + f(i,j,km1)) / std::pow(_h.hk,2.0);
        }
      }
    }
    _dz_computed = true;
  }
  template <typename Func> 
  void laplacien(Func f) override {
    if(!_dx_computed) second_der_x(f);
    if(!_dy_computed) second_der_y(f);
    if(!_dz_computed) second_der_z(f);
    
    for (std::size_t i=0; i<_G.NI ; ++i){
      for (std::size_t j=0; j<_G.NJ; ++j){
	for (std::size_t k=0; k<_G.NK; ++k){
	  _delta(i,j,k) = _dx(i,j,k)+_dy(i,j,k)+_dz(i,j,k); 
	}
      }
    }
  }
};

template <typename T>
class DF_o4 : public derivative_3D<T>{
public:
  using derivative<T>::_h;
  using derivative<T>::_G;
  using derivative<T>::_dx;
  using derivative<T>::_dy;
  using derivative<T>::_dz;
  using derivative<T>::_delta;
  
  DF_o4(const step_size& h , const Gride3D& g) : derivative_3D<T>(h, g) {}

  template <typename Func>
  void second_der_x(Func f) override {
    for (std::size_t i=0; i<_G.NI ; ++i){
      for (std::size_t j=0; j<_G.NJ; ++j){
	for (std::size_t k=0; k<_G.NK; ++k){
	std::size_t ip1 = (i+1)%_G.NI;
	std::size_t ip2 = (i+2)%_G.NI;
	std::size_t im1 = (i+_G.NI-1)%_G.NI;
	std::size_t im2 = (i+_G.NI-2)%_G.NI;

	_dx(i,j,k) = (-f(ip2,j,k) + 16.0*f(ip1,j,k) - 30.0*f(i,j,k)
		      + 16.0*f(im1,j,k)- f(im2,j,k))/(12.0 * std::pow(_h.hi,2.0));
	}
      }
    }
  }
  template <typename Func>
  void second_der_y(Func f) override {
    for (std::size_t i=0; i<_G.NI ; ++i){
      for (std::size_t j=0; j<_G.NJ; ++j){
        for (std::size_t k=0; k<_G.NK; ++k){
        std::size_t jp1 = (j+1)%_G.NJ;
        std::size_t jp2 = (j+2)%_G.NJ;
        std::size_t jm1 = (j+_G.NJ-1)%_G.NJ;
        std::size_t jm2 = (j+_G.NJ-2)%_G.NJ;

        _dy(i,j,k) = (-f(i,jp2,k) + 16.0*f(i,jp1,k) - 30.0*f(i,j,k)
                      + 16.0*f(i,jm1,k)- f(i,jm2,k))/(12.0 * std::pow(_h.hj,2.0));
        }
      }
    }
  }
  template <typename Func>
  void second_der_x(Func f) override {
    for (std::size_t i=0; i<_G.NI ; ++i){
      for (std::size_t j=0; j<_G.NJ; ++j){
        for (std::size_t k=0; k<_G.NK; ++k){
	std::size_t kp1 = (k+1)%_G.NK;
        std::size_t kp2 = (k+2)%_G.NK;
        std::size_t im1 = (k+_G.NK-1)%_G.NK;
        std::size_t im2 = (k+_G.NK-2)%_G.NK;

        _dx(i,j,k) = (-f(i,j,kp2) + 16.0*f(i,j,kp1) - 30.0*f(i,j,k)
                      + 16.0*f(i,j,km1)- f(i,j,km2))/(12.0 * std::pow(_h.hk,2.0));
        }
      }
    }
  }
  template <typename Func>
  void laplacien(Func f) override {
    if(!_dx_computed) second_der_x(f);
    if(!_dy_computed) second_der_y(f);
    if(!_dz_computed) second_der_z(f);

    for (std::size_t i=0; i<_G.NI ; ++i){
      for (std::size_t j=0; j<_G.NJ; ++j){
        for (std::size_t k=0; k<_G.NK; ++k){
          _delta(i,j,k) = _dx(i,j,k)+_dy(i,j,k)+_dz(i,j,k);
        }
      }
    }
  }

};

